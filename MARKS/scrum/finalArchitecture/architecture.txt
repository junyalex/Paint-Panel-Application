# Architecture

# MVC
# ModelClasses
	Paint , PaintModel, Shape, Circle, Oval, Rectangle, Triangle, Polyline,
	Scribble, Point

# ViewClasses
	PaintPanel,
# ControllerClasses
	ColorEventHandler, FillStyleEventHandler, redoEventHandler, undoEventHandler


# (other logical  ways of collecting your classes)

# Design Patterns Used (collections of classes into DP)
--------------------------------------------------------------------------------
Name: Hojun Lee
Pattern Name: Strategy
Reference:
	https://www.oodesign.com/strategy-pattern/
Purpose:
       - SRP : Used strategy pattern to separates Shape and codes for drawing.
       Shape only contains the information of the object shape, and shape does not know
       how they are being drawn by users.
       - Open-Closed Principle (OCP) : New shapes can be added easily.
       For example, if programmer wants to add new shape like star, they only need to
       implement the StarDrawStrategy.
       - DIP : Shape only depends on DrawStrategy interface , instead of concrete strategies.
UML:
	Strategy.uml in finalArchitecture.

Classes:
	- Context: PaintPanel
    - Strategy: DrawStrategy
    - ConcreteStrategies:
      - CircleDrawStrategy
      - OvalDrawStrategy
      - RectangleDrawStrategy
      - TriangleDrawStrategy
      - PolylineDrawStrategy
      - ScribbleDrawStrategy
      - SquareDrawStrategy


Usage:
	By using strategy pattern, drawing methods are separated for each shapes in different
	classes which makes the code precise, and allows programmers to add new drawing strategy.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Name: Hojun Lee
Pattern Name: Factory
Reference:
	http://www.oodesign.com/factory-pattern.html
Purpose:
	SRP : ShapeFactory class has the single responsibility of creating Strategy objects for drawing	needed for the draw.
	OCP : By using factory pattern, new strategy of a shape class can be added
		without modifying PaintPanel class. Before factory pattern was used, there were if statements for every shapes
		selected, but by using factory pattern, code became concise.

UML:
	Factory.uml in finalArchitecture.

Classes:
	Factory :
	-ShapeFactory
	Client:
	-PaintPanel

	Product:
	-DrawStrategy

	Concrete Product :
      - CircleDrawStrategy
      - OvalDrawStrategy
      - RectangleDrawStrategy
      - TriangleDrawStrategy
      - PolylineDrawStrategy
      - ScribbleDrawStrategy
      - SquareDrawStrategy

Usage:
	By using Factory pattern, when there is new strategy class to be added,
	it allows us to simply add new strategy class to factory class without modifying
        the PaintPanel class.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Name: Hojun Lee
Pattern Name: Command Pattern
Reference:
	https://www.oodesign.com/command-pattern
Purpose:
	SRP : Each command class has a single responsibility of
	handling execution, undo, and redo operations.
	OCP  : New type of commands can be added by creating new concrete command class.
UML:
	Command.uml in finalArchitecture.

Classes:
	Command - Command

	Invoker - PaintModel, undoEventHandler, redoEventHandler

ConcreteCommand
- DrawCircleCommand
- DrawOvalCommand
- DrawPolylineCommand
- DrawRectangleCommand
- DrawScribbleCommand
- DrawSquareCommand
- DrawTriangleCommand
- MoveShapeCommand


Receiver
- Shape
- PaintModel

Client
- DrawStrategy

Usage:
	In order to create a sequence of commands that are executed by users, command
	pattern is used. Also, it allows us to implement undo / redo function by using
	command pattern.

--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Name: Sungmin Cho
Pattern Name: Observer/Observable
Reference:
	https://en.wikipedia.org/wiki/Observer_pattern
Purpose:
       - Encapsulation :
       In PaintModel(observable), the observer pattern was used to notify PainPanel(observer)
       everytime the state of the model changes. Since PaintModel notifies PainPanel using setChanged() and
       notifyObservers(), we can prevent the exposure of implementations or code structures. Thus, by using observer
       pattern, we can maintain the encapsulation of internal details of PaintModel.

       - Single Responsibility Principle (SRP):
       PainModel is responsible only for modeling the state of the paint. Furthermore, PainPanel is only responsible
       for drawing shapes on the screen based on state of the paint model. By using Observer pattern, PaintPanel
       automatically updates the changes of the state and PaintModel doesn't have to know how PainPanel displays
       changes.

       - Open/Closed Principle (OCP):
       By using Observer pattern, we can add any numbers of observers (ex. another type of view) without modifying
       PaintModel class. Thus, PaintModel is opened for extension but closed for modification.

UML:
	ObserverPattern.uml in finalArchitecture.

Classes:
	- Observer: PaintPanel
    - Observable: PaintModel

Usage:
	Automatically updates the UI whenever user makes an input and changes the state of the PaintModel. By doing
	so, we can keep the synchronization between model and view. Moreover, using observer pattern,
	we can have better code maintainability by clearly dividing responsibilities of the model and the view.
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
Name: Sungmin Cho
Pattern Name: Singleton Pattern
Reference:
	https://en.wikipedia.org/wiki/Singleton_pattern
Purpose:
    - Single Responsibility Principle (SRP):
    FillStyleManager has single responsibility of managing current fill style. By using
    singleton pattern, it ensures there is only one instance that handle each responsibility.

    - Centralized Control:
    Once fill style is set, it should be fixed for any drawing in paint until user changes the style. Using
    singleton pattern, no matter where you need information about current fill style, you can always interact with
    same instance of FillStyleManager.

    - Memory Efficiency:
    Using singleton pattern, we can save the memory since only one instance of FillStyleManager is ever created.

UML:
	SingletonPattern.uml in finalArchitecture.

Classes:
    - FillStyleManager

Usage:
	By using singleton pattern, we do not have to keep track of multiple instances for current fill style.
	Furthermore, it ensures global access to current fill style. Therefore, whenever the style changes by the user,
	the changed style will be applied to further drawing of the user.

--------------------------------------------------------------------------------

# High Level Architecture Discussion

	(Put all of the above together in a collection of stories which tell the
	developer how to modify, extend, or understand your code)

	(For each story, pull from and modify the highLevelTemplate.txt)

--------------------------------------------------------------------------------
New Drawing Mode: Drawing shapes
Description:

	Shape buttons are displayed on the left side of the canvas. Users can pick the shape
	they would like to draw by clicking on one of the shape buttons.

	When users click shape button, it selects the mode and a strategy for handling
	user input for drawing mode is installed.

	PaintPanel class handles 3 types of mouse events. Pressed, Dragged and Released.
	When users trigger mouse events, with selected strategy, it draws the shape on the canvas
	users can see it. By using observer pattern, whenever there is a modification to the
	PaintModel (Observable), it notifies to PaintPanel (Observer) that there was a modification
	to the model, PaintPanel updates itself and users can see the changes they have made which means
	they can see the shape they have drawn through the screen.

Implementation:

	image icon: Image icons are displayed by Strings that users can recognize. Buttons that show
	different types of shape are added to ShapeChooserPanel.

	Draw Strategy : Since different types of drawing technique is required for each shape,
	Strategy pattern is used. Each shape has their own DrawStrategies when User chooses a shape,
	it calls setMode() method in PaintPanel class. In setMode() method, it uses ShapeFactory class
	which creates concrete classes of DrawStrategy class to create proper object of Strategy.
	Once Strategy object is created, users can draw shapes by 3 steps.

	1 : Once mouse is pressed, it creates new Shape object.

	2 : While users are dragging, in order to let them see the current status of shape so users can
	    see how it is being drawn, shape will be added to PreviewShapes, which is an ArrayList.

	3. When mouse is released, it adds to Shapes ArrayList, and shapes created while dragging
	   gets deleted.

Example: for drawing circle :
    PaintModel.java, PaintPanel.java, DrawStrategy.java, RectangleDrawStrategy.java, ShapeFactory.java
    SelectMode.java
--------------------------------------------------------------------------------
--------------------------------------------------------------------------------
New Drawing Mode: Undo / Redo Operations (Command Pattern)
Description:

	The undo / redo functionality is implemented through command pattern, which allows users to
	remove or restore the shape.

Implementation:

	UndoRedoPanel : There are two buttons on the left side of the canvas,
	Button with '↶'  is for undo and  '↷' is for redo.

	When user releases the mouse and finish drawing shape, it creates a new Command that stores
	which shape is drawn. Command class has two methods, execute() and undo().

    When mouse is released, it executes execute() method and the shape gets added to Shapes ArrayList in
    PaintModel class. Also, a Command instance that is created in the DrawStrategy calls executeCommand()
    to the PaintModel. Also, it will be added to commandHistory, which is a stack to have all commands
    that are executed.

    PaintModel has two different functions : undo and redo.

    When undo() is called, if there is a commandHistory is not empty, it pops the last command
    and push it to the other stack, which is undoHistory which stores commands that are undo by users.

    Also, it calls undo() for popped command and the shape will be deleted from Shapes ArrayList.

    When redo() is called, it pops a command from undoHistory, execute the command again so
    the shape that was undo will be added to the shapes ArrayList again and will be restored.

    Also, when command is redo, it adds back to commandHistory ArrayList.

    By using command patterns, users can undo / redo shapes they have drawn.


Example: for undo / redo  :
    PaintModel.java, Command.java, Concrete command classes ( For example, DrawOvalCommand,
    DrawTriangleCommand, etc.) UndoRedoPanel.java,  undoEventHandler, redoEventHandler,
    DrawStrategy.
--------------------------------------------------------------------------------
New Drawing Mode: Change fill style
Description:

    Change fill style functionality is implemented through a singleton pattern, which allows the user to draw
    shapes with the style that the user selected, until they change it to another style.

Implementation:

    You can change the fill style from the "Style" menu which is on the right side of the menu bar at the top of
    the Paint app. From the "Style" menu, go to "Fill style", and there are two styles you can change which are
    "Filled" and "Outlined".

    FillStyleEventHandler:
        The UI of the "Fill style" menu is implemented in the View class. When the user changes the style from the
        "Fill style" menu, FillStyleEventHandler retrieves which style the user selected, and updates the currentStyle
        of the FillStyleManager instance (using setStyle() method).

    FillStyleManager:
        This class is implemented based on a singleton pattern. Whenever a Shape class object is created,
        the Shape class constructor retrieves the current style from the FillStyleManager singleton
        instance (using the getStyle() method) and set it as a fillStyle of the Shape object. The default style is
        set to "Outlined" in FillStyleManger.

        Based on the fillStyle of the Shape object, each shape's draw strategy will draw the shape based on the current
        fillStyle of the shape. Shape class is the superclass of all shapes(oval, circle, rectangle, etc.). Thus,
        each shape will be drawn based on the current fill style set by the user, and this will remain the same
        until the user changes the fill style.

    By using a singleton pattern for FillStyleManager, a single instance of the class allows the fill style to be
    consistently accessed and modified globally.


Example: for changing fill style (let drawing shape is Oval):
    User changed fill style:
        View.java -> FillStyleEventHandler.java (handle()) -> FillStyleManager.java (setStyle())

    User draw Oval shape with changed fill style:
        Based on "Drawing shapes", Oval.java will be added to "shapes" Arraylist in PaintModel.java, using addShape() ->
        PaintPanel.java (update())  ->  PaintModel.java (drawAllShapes()) ->  Shape.java (getFillStyle()) ->
        Oval.java (getDrawStrategy()) -> OvalDrawStrategy (draw())
--------------------------------------------------------------------------------
